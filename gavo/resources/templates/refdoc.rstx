========================================
GAVO DC Software Reference Documentation
========================================


.. contents:: 
  :depth: 2
  :backlinks: entry
  :class: toc


Resource Descriptor Element Reference
=====================================

The following (XML) elements are defined for resource descriptors.  Some
elements are polymorous (Grammars, Cores).  See below for a reference
on the respective real elements known to the software.

In general, items defaulting to Undefined are mandatory.  Failing to
give a value will result in a parse error.  Exceptions to this rule are
given at the respective elements.

.. replaceWithResult getStructDocs(docStructure)


Active Tags
===========

The following tags are "active", which means that they do not directly
contribute to the RD parsed.  Instead they define, replay, or edit
streams of elements.

.. replaceWithResult getActiveTagDocs(docStructure)


Grammars Available
==================

The following elements are all grammar related.  All grammar elements
can occur in data descriptors.

.. replaceWithResult getGrammarDocs(docStructure)

Cores Available
===============

The following elements are related to cores.  All cores can only occur
toplevel, i.e. as direct children of resource descriptors.  Cores are
only useful with an id to make them referencable from services using
that core.

.. replaceWithResult getCoreDocs(docStructure)

Mixins
======

Mixins ensure a certain functionality on a table.  Typically, this is
used to provide certain guaranteed fields to particular cores.  For many
mixins, there are predefined procedures (both rowmaker applys and
grammar rowfilters) that should be used in grammars and/or rowmakers
feeding the tables mixing in a given mixin.

.. replaceWithResult getMixinDocs(docStructure)


Triggers
========

In the context of the GAVO DC, triggers are conditions on rows -- either
the raw rows emitted by grammars if they are used within grammars, or
the rows about to be shipped to a table if they are used within
tables.  Triggers may be used recursively, i.e., triggers may contain
more triggers.  Child triggers are normally or-ed together.

Currently, there is one useful top-level trigger, the `element
ignoreOn`_.  If an ignoreOn is triggered, the respective row is silently
dropped (actually, you ignoreOn has a bail attribute that allows you to
raise an error if the trigger is pulled; this is mainly for debugging).

The following triggers are defined:

.. replaceWithResult getTriggerDocs(docStructure)


Renderers Available
===================

The following renderers are available for allowing and URL creation.
The parameter style is relevant when adapting `condDescs`` or table
based cores to renderers:

* With clear, parameters are just handed through
* With form, suitable parameters are turned into vizier-like expressions
* With pql, suitable parameters are turned into their PQL counterparts,
  letting you specify ranges and such.

Unchecked renderers can be applied to any service and need not be
explicitely allowed by the service.

.. replaceWithResult getRendererDocs(docStructure)


Predefined Procedures
=====================

Procedures available for rowmaker apply
'''''''''''''''''''''''''''''''''''''''

.. replaceWithResult makeRmkProcDocs(docStructure)


Procedures available for grammar rowfilters
'''''''''''''''''''''''''''''''''''''''''''

.. replaceWithResult makeRowfilterDocs(docStructure)


Metadata
========

Various elements support the setting of metadata through meta elements.
Metadata is used for conveying RMI-style metadata used in the VO
registry.  See [RMI]_ for an overview of those.  We use the keys given
in RMI, but there are some extensions discussed in `RMI-style
Metadata`_.

The other big use of meta information is for feeding templates.  Those
"local" keys should all start with an underscore.  You are basically
free to use those as you like and fetch them from your custom templates.
The predefined templates already have some meta items built in,
discussed in `Template Metadata`.

So, metadata is a key-value mapping.  Keys may be compound like in RMI,
i.e., they may consist of period-separated atoms, like
publisher.address.email.  There may be multiple items for each meta
key.

Meta inheritance
''''''''''''''''

When you query an element for metadata, it first sees if it has this
metadata.  If that is not the case, it will ask its meta parent.  This
usually is the embedding element.  It wil again delegate the request to
its parent, if it exists.  If there is no parent, configured defaults
are examined.  These are taken from rootDir/etc/defaultmeta, where they
are given as colon-separated key-value pairs, e.g.,

::

  publisher: The GAVO DC team
  publisherID: ivo://org.gavo.dc
  contact.name: GAVO Data Center Team
  contact.address: Moenchhofstrasse 12-14, D-69120 Heidelberg
  contact.email: gavo@ari.uni-heidelberg.de
  contact.telephone: ++49 6221 54 1837
  creator.name: GAVO Data Center
  creator.logo: http://vo.ari.uni-heidelberg.de/docs/GavoTiny.png

The effect is that you can give global titles, descriptions, etc.
in the RD but override them in services, tables, etc.  The configured
defaults let you specify meta items that are probably constant for
everything in your data center, though of course you can override these
in your RD elements, too.

In HTML templates, missing meta usually is not an error.  The
corresponding elements are just left empty.  In registry documents,
missing meta may be an error.

Meta formats
''''''''''''

Metadata must work in registry records as well as in HTML pages and
possibly in other places.  Thus, it should ideally be given in formats
that can be sensibly transformed into the various formats.

The GAVO DC software knows four input formats:

literal
  The textual content of the element will not be touched.  In
  HTML, it will end up in a div block of class literalmeta.

plain
  The textual content of the element will be whitespace-normalized,
  i.e., whitespace will be stripped from the start and the end,
  runs of blanks and tabs are replaced by a single blank, and empty
  lines translate into paragraphs.  In HTML, these blocks com in
  plainmeta div elements.  

rst
  The textual content of the element is interpreted as restructured
  text.  When requested as plain text, the restructured text itself is
  returned, in HTML, the standard docutils rendering is returned.

raw
  The textual content of the element is not touched.  It will be
  embedded into HTML directly.  You can use this, probably together
  with CDATA sections, to embed HTML -- the other formats should not
  contain anything special to HTML (i.e., they should be PCDATA in
  XML lingo).  While the software does not enforce this, raw content
  should not be used with RMI-type metadata.  Only use it for items that
  will not be rendered outside of HTML templates.


Macros in Meta Elements
'''''''''''''''''''''''

Macros will be expanded in meta items using the embedding element as
macro processors (i.e., you can use the macros defined by this element).


Typed Meta Elements
'''''''''''''''''''

While generally the DC software does not care what you put into meta
items and views them all as strings, certain elements are treated
specially.  The following meta element "types" are currently defined:

.. replaceWithResult getMetaTypeDocs()

While in XML meta, you can explicitely set the type of a meta item
(using the type attribute), it is more common to just use the inferred
type by the meta name.  Currently, the following meta keys imply types:

.. replaceWithResult getMetaTypedNames()

For type inference, only the last component of a meta path is
significant, i.e., both creator.logo and publisher.logo are of type
logo.


Metadata in Standard Renderers
''''''''''''''''''''''''''''''

Certain meta keys have a data center-internal interpretation, used
in renderers or writers of certain formats.  These keys should always
start with an underscore.  Among those are:

* _intro -- used by the standard HTML template for explanatory text
  above the seach form.
* _bottominfo -- used by the standard HTML template for explanatory text
  below the seach form.
* _copyright -- used by the standard HTML template for copyright-related
  information (there's also copyright in RMI; the one with the
  underscore is intended to be less formal).
* _related -- used in the standard HTML template for links to related
  services.  As listed above, this is a link, i.e., you can give a
  title attribute.
* _longdoc -- used by the service info renderer for an explanatory
  piece of text of arbitrary length.  This will usually be in
  reStructured text, and we recommend having the whole meta body in a
  CDATA section.
* _news -- news on the service.  See above at `Typed Meta Elements`_.
* _warning -- used by both the VOTable and the HTML table renderer.
  The content is rendered as some kind of warning.  Unfortunately,
  there is no standard how to do this in VOTables.  There is no
  telling if the info elements generated will show anywhere.
* _noresultwarning -- displayed by the default response template instead
  of an empty table (use it for things like "No Foobar data for your
  query")
* _type -- on Data instances, used by the VOTable writer to set the
  ``type`` attribute on ``RESOURCE`` elements (to either "results"
  or "meta").  Probably only useful internally.


RMI-Style Metadata
''''''''''''''''''

For services (and other things) that are registred in the Registry, you
must give certain metadata items (and you can give more), where we take
their keys from [RMI]_.  We provide a `explanatory leaflet
<./data_checklist.pdf>`_ for data providers.  The most common keys --
used by the registry interface and in part by HTML and VOTable
renderers -- include:

* title -- this should in general be given seperately on the resource,
  each table, and each service.  In simple cases, though, you may get by
  by just having one global title on the resource and rely on metdata
  inheritance.
* shortName -- a string that should indicate what the service is in 16
  characters or less.
* creationDate -- Use ISO format with time, UTC only, like this: 
  2007-10-04T12:00:00Z
* subject -- as noted in the explanatory leaflet, these should be taken
  from the `IVOA Vocabulary Explorer
  <http://explicator.dcs.gla.ac.uk/WebVocabularyExplorer/>`_.
* copyright -- freetext copyright notice.
* source -- bibcodes will be expanded to ADS links here.
* referenceURL -- again, a link, so you can give a title for
  presentation purposes.  If you give no referenceURL, the service's
  info page will be used.
* dateUpdated -- an ISO date.  Do not set this.  This is determined
  from timestamps in DaCHS's state directory.  There is also
  datetimeUpdated that you would have to keep in sync with dateUpdated
  if you were to change it.
* facility -- no IVOA ids are supported here yet, but probably this
  should change.
* coverage -- see the special section to be written
* service-specific metadata (for SIA, SCS, etc.) -- see the
  documentation of the respective cores.

While you can set any of these in etc/defaultmeta.txt, the following items
are usually set there:

* publisher
* publisherID
* contact.name
* contact.address
* contact.email
* contact.telephone
* creator.name -- you may want to override this with actual author
  names.
* creator.logo -- this should probably be overridden as well if you
  override creator.name


Display Hints
=============

Display hints use an open vocabulary.  As you add value formatters, you can 
evaluate any display hint you like.  Display hints understood by the
built-in value formatters include:

checkmark
  in HTML tables, render this column as empty or checkmark depending on
  whether the value is false or true to python.

displayUnit
  use the value of this hint as the unit to display a value in.

humanTime
  display values as h:m:s.

nopreview
  if this key is present with any value, no HTML code to generate
  previews when mousing over a link will be generated.

sepChar
  a separation character for sexagesimal displays and the like.

sf
  "Significant figures" -- length of the mantissa for this column.
  Will probably be replaced by a column attribute analoguous to what
  VOTable does.

type
  a key that gives hints what to do with the column.  Values currently
  understood include:

  bar
    display a numeric value as a bar of length value pixels.

  bibcode
   display the value as a link to an ADS bibcode query.

  feedbackSelect
    used by the feedback machinery to designate the column containing
    the feedback key (will be rendered as a checkbox in HTML).

  keephtml
    lets you include raw HTML.  In VOTables, tags are removed.

  product
    treats the value as a product key and expands it to a URL for the
    product (i.e., typically image).  This is defined in
    protocols.products.  This display hint is also used by, e.g., the tar
    format to identify which columns should contribute to the tar file.

  sexagesimal
    format a float as degree, minutes, seconds.

  simbadlink
    formats a column consisting of alpha and delta as a link to query
    simbad.  You can add a coneMins displayHint to specify the search
    radius.

  suppress
    do not automatically include this column in any table (e.g.,
    verbLevel-based column selection).

  time
    force formatting of this column as a time (with unit like hms).

  url
    makes value a link in HTML tables.

noxml
  if 'true' (exactly like this), do not include this column in VOTables.

width
  preview width in pixels.

Note that not any combination of display hints is correctly
interpreted.  The interpretation is greedy, and only one formatter at a
time attempts to interpret display hints.


Writing Custom Cores
====================

At some point you will want functionality in your applications that goes
beyond the simple actions provided by the packaged cores.  You can use
custom renderers to, in effect, bypass most of the DC's functionality,
but you will usually gain flexibility if you define a custom core.

Defining a Custom Core
''''''''''''''''''''''

To do this, you need to write a python module.  The standard location
for those is in the bin/ subdirectory of the resource directory.

You will usually want to inherit from core::

  from gavo.svcs import core

  class Core(core.Core):

The framework will always look of an object named "Core" in the module
and use this as the custom core.

The core needs an InputTable and an OutputTable like all cores.  You
*could* define it in the resource descriptor like this::

  <customCore id="createCore" module="bin/create">
    <inputTable>
      <inputKey .../>
    </inputTable>
    <outputTable>
      <column name="itemsAdded" type="integer" tablehead="Items added"/>
    </outputTable>
  </customCore>

It's probably a better idea to define it in the code, though, since
then it will work without further specifications.  The definitions
in the code can still be overridden from an RD for special effects.
Embedding the definitions is done using the class attributes
``inputTableXML`` and ``outputTableXML``::

  class Core(core.Core):
    inputTableXML = """<inputTable>
      <inputKey name="fileSrc" type="file" tablehead="Local file"
        description="A local file to upload (overrides source URL if given).">
      <inputKey name="tableName" type="text" tablehead="Target Table"
        description="Name of the table to match against.  
          Only tables available for ADQL (see there) can be used here.">
        <values fromdb="tablename from dc_tables where adql=True"/>
      </inputTable>
      """
    # we don't know what's going to be in the output table until we
    # know both the uploaded table and the tableName
    outputTableXML = """<outputTable/>"""

You should not override the constructor.  If you need to perform
"expensive" instanciations, override the completeElement method, as in
the following template::

  def completeElement(self):
    <your code>
    self._completeElementNext(Core)

The call to _completeElementNext ensures that the remaining
completeElement methods are executed.

Giving the Core Functionality
'''''''''''''''''''''''''''''

To have the core do something, you have to override the run method,
which has to have the following signature::

  run(service, inputTable, queryMeta) -> stuff

The stuff returned will ususally be a Table instance (that need not
match the outputTable definition -- the latter is targetted at the
registry and possibly applications like output field selection).  The
standard renderers also accept a mime type and a string containing
some data and will deliver this as-is.  With custom renderers, you could
return basically anything you want.

Services come up with some idea of the schema of the table they want to
return and adapt tables coming out of the core to this.  Sometimes, you
want to suppress this behaviour, e.g., because the service's ideas are
off.  In that case, set a noPostprocess atttribute on the table to any
value.

service is a service instance.  In particular, you can access the RD you
are running in through its rd attribute.  This is useful if you need to
resolve, e.g., table references (which, in this case, could be given as
a service property)::

  pertainingTable = service.rd.getById(
    service.getProperty("pertainingTable"))

inputTable is a Table instance. Unless the service has a fancy inputDD,
you simply find the inputKey values in the table's parameters::

  val = inputTable.getParam("fileSrc")



Errors
''''''

To bail out from processing, raise a validation error.  Construct it
with a message and the name of an input key.  At least for the form
renderer, this causes a sensible error message with some hint as the the
originating input field::

	raise base.ValidationError("Invalid file name", "rdsrc")


Database Options
''''''''''''''''

The standard DB cores receive a "table widget" on form generation,
including sort and limit options.  To make the Form renderer output this
for your core as well, define a method wantsTableWidget() -> True.

The queryMeta that you receive in run has a dbLimit key.  It contains
the user selection or, as a fallback, the global db/defaultLimit value.
These values are integers.

So, if you order a table widget, you should do something like::

  cursor.execute("SELECT .... LIMIT %(queryLimit)s", 
    {"queryLimit": queryMeta["dbLimit"],...})

In general, you should warn people if the query limit was reached; a
simple way to do that is::

	if len(res)==queryLimit:
		res.addMeta("_warning", "The query limit was reached.  Increase it"
			" to retrieve more matches.  Note that unsorted truncated queries"
			" are not reproducible (i.e., might return a different result set"
			" at a later time).")

where res would be your result table.  _warning metadata is displayed in
both HTML and VOTable output, though of course VOTable tools will not
usually display it.

Inheriting from TableBasedCore
''''''''''''''''''''''''''''''

TBD

Writing Custom Grammars
=======================

A custom grammar simply is a python module located within a resource
directory defining a row iterator class derived from
gavo.grammars.customgrammar.CustomRowIterator; this class must be called
RowIterator.  You want to override the _iterRows method.  It will have
to yield row dictionaries, i.e., dictionaries mapping string keys to
something (preferably strings, but you will usually get away with
returning complete values even without fancy rowmakers).  

So, a custom grammar module could look like this::

  from gavo.grammars.customgrammar import CustomRowIterator

  class RowIterator(CustomRowIterator):
    def _iterRows(self):
      for i in xrange(10000):
        yield {'index': i, 'square': i**2}

Do not override magic methods, since you may lose row filters, sourceFields,
and the like if you do.  An exception is the constructor.  If you must,
you can override it, but you must call the parent constructor, like
this::

  class RowIterator(CustomRowIterator):
    def __init__(self, grammar, sourceToken, sourceRow=None):
      CustomRowIterator.__init__(self, grammar, sourceToken, sourceRow)
      <your code>

The sourceToken, in general, will be a file name, unless you call
makeData manually and forceSource something else.

A row iterator will be instanciated for each source processed.  Thus,
you should usually not perform expensive operations in the constructor
unless they depend on sourceToken.  In general, you should rather define
a function makeDataPack in the module.  Whatever is returned by this
function is available as self.grammar.dataPack in the row iterator.

The function receives an instance of the the customGrammar as an
argument.  This means you can access the resource descriptor and
properties of the grammar.  As an example of how this could be used,
consider this RD fragment::

  <table id="defTable">
    ...
  </table>

  <customGrammar module="res/grammar">
    <property name="targetTable">defTable</property>
  </customGrammar>

Then you could have the following in res/grammar.py::

  def makeDataPack(grammar):
    return grammar.rd.getById(grammar.getProperty("targetTable"))

and access the table in the row iterator.

Also look into EmbeddedGrammar, which may be a more convenient way to
achieve the same thing.


Functions Available for Row Makers
==================================

In principle, you can use arbitrary python expressions in var, map and
proc elements of row makers.  In particular, the namespace in which
these expressions are executed contains math, os, re, time, and datetime
modules as well as gavo.base, gavo.utils, and gavo.coords.

However, much of the time you will get by using the following functions
that are immediately accessible in the namespace:

.. replaceWithResult getRmkFuncs(docStructure)



Scripting
=========

As much as it is desirable to describe tables in a declarative manner,
there are quite a few cases in which some imperative code helps a lot
during table building or teardown.  Resource descriptors let you embed
such imperative code using script elements.  These are children of the
make elements since they are exclusively executed when actually
importing into a table.

Currently, you can enter scripts in SQL and python, which may be called
at various phases during the import.

SQL scripts
'''''''''''

In SQL scripts, you separate statements with seimcolons.  Note that no
statements in an SQL script may fail since that will invalidated the
transaction.  You should, however, not commit or begin transactions in
SQL scripts as long as Postgres  does not support nested transactions.

You can use table macros in the SQL scripts to parametrize them; the
most useful among those probably is ``\curtable`` containing the fully
qualified name of the table being processed.

Python scripts
''''''''''''''

Python scripts can be indented by a constant amount.

The table object currently processed is accessible as table.  In
particular, you can use this to issue queries using 
``table.query(query, arguments)`` (parallel to dbapi.execute) and to
delete rows using ``table.deleteMatching(condition, pars)``.

Some types of scripts may have additional names available, but this
currently is only true for newSource, where the sourceToken of the new
source is provided.

Script types
''''''''''''

The type of a script corresponds to the event triggering its execution.
The following types are defined right now:

* preImport -- before anything is written to the table
* newSource -- every time a new source is started
* preIndex -- before the indices on the table are built
* postCreation -- after the table (incl. indices) is finished
* beforeDrop -- when the table is about to be dropped


Examples
''''''''

This snippet sets a flag when importing some source (in this case,
that's an RD, so we can access sourceToken.sourceId::

			<script type="newSource" lang="python" id="markDeleted">
				table.query("UPDATE %s SET deleted=True"
					" WHERE sourceRD=%%(sourceRD)s"%id, 
					{"sourceRD": sourceToken.sourceId})
			</script>


This is a hacked way of ensuring some sort of referential integrity:
When a table containing "products" is dropped, the corresponding entries
in the products table are deleted::

  <script type="beforeDrop" lang="SQL" name="clean product table">
    DELETE FROM products WHERE sourceTable='\curtable'
  </script>

Note that this is actually quite hazardous because if the table is
dropped in any way not using the make element in the RD, this will not
be executed.  It's usually much smarter to tell the database to do the
housekeeping.  Rules are typically set in postCreation scripts::

  <script type="postCreation" lang="SQL">
    CREATE OR REPLACE RULE cleanupProducts AS 
      ON DELETE TO \curtable DO ALSO
			DELETE FROM products WHERE key=OLD.accref
  </script>

The decision if such arrangements are make before the import, before the
indexing or after the table is finished needs to be made based on the
script's purpose.

Another use for scripts is SQL function definition::

			<script type="postCreation" lang="SQL" name="Define USNOB matcher">
				CREATE OR REPLACE FUNCTION usnob_getmatch(alpha double precision, 
					delta double precision, windowSecs float
				) RETURNS SETOF usnob.data AS $$
				DECLARE
					rec RECORD;
				BEGIN
					FOR rec IN (SELECT * FROM usnob.data WHERE 
						q3c_join(alpha, delta, raj2000, dej2000, windowSecs/3600.)) 
					LOOP
						RETURN NEXT rec;
					END LOOP;
				END;
				$$ LANGUAGE plpgsql;
			</script>

You can also load data, most usefully in preIndex scripts (although
beforeImport would work as well here)::

		<script type="preIndex" lang="SQL" name="create USNOB-PPMX crossmatch">
				SET work_mem=1000000;
				INSERT INTO usnob.ppmxcross (
					SELECT q3c_ang2ipix(raj2000, dej2000) AS ipix, p.localid 
					FROM 
						ppmx.data AS p, 
						usnob.data AS u 
					WHERE q3c_join(p.alphaFloat, p.deltaFloat, 
						u.raj2000, u.dej2000, 1.5/3600.))
			</script>



Bibliography
============

.. [RMI]  Hanisch, R., et al, "Resource Metadata for the Virtual
   Observatory", http://www.ivoa.net/Documents/latest/RM.html
