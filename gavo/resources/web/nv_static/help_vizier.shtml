<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
	"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Help: Vizier-like expressions</title>
<link rel="stylesheet" type="text/css"
	href="__site_path__/static/css/gavo_dc.css"/>
</head>
<body>
<h1>Help on Vizier-like expressions</h1>
<p>The GAVO archive supports search expressions modelled after <a href="http://vizier.u-strasbg.fr/cgi-bin/Help?VizieR/syntax">what 
CDS' Vizier service provides</a>.  Our implementation is not yet complete. 
If you need a given feature, please let us know.</p>

<p>The rough idea is that you can specify
the values you search for with certain operators, depending on the type
of the field you are matching against.</p>

<h2><a name="floats">Vizier-like expressions for numeric values</a></h2>
<h3>Overview</h3>
<p>For numeric expressions, you can use the following operators:</p>
<ul>
<li>No operator: this is equivalent to =.</li>
<li>Comparisons: The operators &lt;, &lt;=, >, >=, =, != are prefixed
and behave like their mathematical counterparts.</li>
<li>Enumeration: You can enumerate values you are interested in using
the comma (",") operator.</li>
<li>Range: To specify a range of acceptable values, use the ".." operator.
Note that you must surround this operator with whitespace; alternatively,
you can give "value and error" with the "+/-" operator.</li>
<li>Logical operators: The operators ! (not), &amp; (and), and | (or) provide
simple logic.  The precendence is in the given sequence.  If you need to do 
fancy things here, contact us and we will add support for grouping (parentheses)
</li>
</ul>

<h3>Examples</h3>
<ul>
<li><code>50</code> or <code>=50</code> -- select only values exactly 50</li>
<li><code>!=50</code> -- select only values different from 50</li>
<li><code>&lt; 60.0</code>; <code>> 4e-8</code>; <code>&gt;= -.5</code>;
<code>&lt;= -5.e13</code> -- selects values smaller, greater, greater or 
equal to their operands.</li>
<li><code>50. .. 80.5</code> -- selects values between 50 and 80.5 inclusive.</li>
<li><code>50 +/- 10</code> -- selects values between 40 and 60 inclusive.</li>
<li><code>40, 50, 50.5, 60</code> -- select any of the enumerated values.</li>
<li><code>!40, 50, 50.5, 60</code> -- select anything other than the enumerated values.</li>
<li><code>40 | 100 +/- 5</code> -- select values equal to 40 or between 95 and 105.</li>
</ul>

<h3>Grammar</h3>
<p>For those into such things, here is the grammar we currently use to parse
numeric expressions (the base nonterminal is expr).

<pre>
	preOp    ::= "=" |  ">=" | ">" | "<=" | "<"
	rangeOp  ::= ".."
	pmOp     ::= "+/-" | "\xb1"  (this is the &#xb1; character)
	orOp     ::= "|"
	andOp    ::= "&"
	notOp    ::= "!"
	commaOp  ::= ","

	preopExpr  ::= [preOp]  floatLiteral
	rangeExpr  ::= floatLiteral rangeOp  floatLiteral
	valList    ::= floatLiteral { commaOp floatLiteral }
	pmExpr     ::= floatLiteral pmOp floatLiteral
	simpleExpr ::= rangeExpr | pmExpr | valList | preopExpr

	notExpr    ::= [notOp] simpleExpr
	andExpr    ::= notExpr {andOp + notExpr}
	expr       ::= andExpr {orOp + expr}
</pre>

<p>floatLiteral is a usual C decimal integer or float literal.</p>


<h2><a name="dates">Vizier-like expressions for dates</a></h2>

<h3>Overview</h3>

<p>Dates support the same operators as <a href="#floats">numeric operands</a>,
except that the "error" in expressions with +/- is a simple float.  Dates
are <em>always</em> in ISO format, i.e., YYYY-MM-DD.  Time specifications are
not yet supported.</p>

<h3>Examples</h3>

<p>See also the examples for <a href="#float">numeric expressions</a>.</p>

<ul>
<li><code><2003-04-06</code> -- select values earlier than 
April 6th, 2003.</li>
<li><code>2003-04-06 +/- 4</code> -- select values four days around 
April 6th, 2003.</li>
</ul>

<h3>Grammar</h3>

<p>The grammar is identical to the one of <a href="#float">numeric 
expressions</a>, except that floatLiteral is dateLiteral with the exception 
of pmExpr that is</p>
<pre>
pmExpr := dateLiteral pmOp floatLiteral</pre>
<p>here.  The dates themselves currently follow the regular expression 
<code>[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]</code>.  This will
be relaxed in the future.</p>

<h2><a name="strings">Vizier-like expression for strings</a></h2>

<h3>Overview</h3>

<p>Strings by default are interpreted as <em>patterns</em>.  A pattern 
contains the meta characters [, ], *, and ?; all others are "normal" 
characters matched literally.  The * matches zero or more characters, the
? exactly one; characters in square brackets match any character enumerated 
within them.  You can use ranges like "A-Z" within square brackets.  If the 
first character in the square brackets is a caret (<code>^</code>), all 
characters except the ones listed are matched.</p>

<p>The following operators can be used when matching strings -- when we talk 
about literals as operands, metacharacter interpretation is suppressed (i.e.,
the strings are matched literally), otherwise we talk about patterns:</p>

<p>Note that both patterns and literally interpreted strings must match
the <em>whole</em> data field.  This is substantially different from the
usual regular expression engines (but corresponds to what you may know 
from filename patterns).</p>

<ul>
<li><code>~</code> -- selects pattern matches of operand ignoring case.
This operand is implied if you give none, which means that <em>by default
you do pattern searches</em>.</li>
<li><code>=</code> -- case-sensitive version of <code>~</code>.</li>
<li><code>!~</code> -- reversal of <code>~</code> (i.e., matches when 
	<code>~</code> doesn't).</li>
<li><code>!</code> -- reversal of <code>=</code>.</li>
<li><code>=~</code> -- selects literal matches of the operand ignoring case.</li>
<li><code>==</code> -- case-sensitive version of <code>=~</code>.</li>
<li><code>!=</code> -- selects all but literal matches of the operand.</li>
<li><code>>=</code>, <code>></code>, <code>&lt;=</code>, <code>&lt;</code> 
-- selects strings larger or equal, larger, etc., than the operand.  </li>
</ul>

<h3>Examples</h3>

<p>TBD</p>

<h3>Grammar</h3>

<p>The following grammar describes the parsing of string expressions:</p>
<pre>
	simpleOperator   ::= "==" | "!=" | ">=" | ">" | "<=" | "<"
	simpleOperand    ::= Regex(".*")
	simpleExpr       ::= simpleOperator + simpleOperand
	
	commaOperand     ::= Regex("[^,]+")
	barOperand       ::= Regex("[^|]+")
	commaEnum        ::= "=," commaOperand { "," commaOperand }
	exclusionEnum    ::= "!=," commaOperand { "," + commaOperand }
	barEnum          ::= "=|" barOperand { "|" + barOperand }
	enumExpr         ::= exclusionEnum | commaEnum | barEnum

	patLiterals      ::= CharsNotIn("[*?")
	wildStar         ::= "*"
	wildQmark        ::= "?"
	setElems         ::= CharsNotIn("]")
	setSpec          ::= "[" + setElems + "]"
	patElem          ::= setSpec | wildStar | wildQmark | patLiterals
	pattern          ::= patElem { patElem }

	patternOperator  ::= "~" | "=" | "!~" | "!"
	patternExpr      ::= patternOperator pattern

	stringExpr       ::= enumExpr | simpleExpr | patternExpr | nakedExpr
</pre>
</body>
</html>
