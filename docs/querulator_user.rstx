=============================
The Querulator -- user manual
=============================

Installation
============

The querulator is contained in the gavo package that also provides a
data ingestor that you should use to provide the data querulator works
on.  First, follow the installation instructions given in the `gavo user
manual <./userman.html>`_.

After the basic gavo installation, you should have a subdirectory
``web_static`` in your GAVO_HOME.  There also should be a script qurun
in a location dependent on your installation.  You need to locate it --
good places too look for it include
``/usr/lib/python<python-version>/site-packages/gavo`` and the same for
/usr/local/lib.

Configuring Postgres
********************

Postgres configuration for querulator only requires an appropriate
gavosettings file to connect querulator to the database with low
privileges.  If you followed the instructions in the gavo package
user manual, you will have a working one in
``$GAVO_HOME/web/gavosettings``.

Configuring Apache
******************

Querulator currently can run as a CGI and under mod_python. You should
start with CGI and should be able to make it work with most any
webserver in this way.  Here, we only describe what to do with apache.
If after a while, you want it to handle more load or respond quicker,
try mod_python.

Static Data
+++++++++++

Querulator needs some static data (for both mod_python and CGI).  In the
appropriate configuration file see (below for a debian example), say
something like

::

  Alias /qstatic /var/gavo/web_static

After restarting your server, you should see a red triangle when
pointing it to http://<your server>/qstatic/sortedArrow.png.

CGI Installation
++++++++++++++++

You need to tell apache how to find querulator and what to do with it,
and you need to make apache tell the querulator what URLs apache will
give it.  The following configuration can be top-level or within a
virtual server.

First, tell apache about the script, e.g.,

::

  ScriptAlias /ql /usr/lib/python2.4/site-packages/gavo/web/qurun

This would let the querulator appear under ``/ql`` (we'll call this the
QU_ROOT).  You can use any valid path as QU_ROOT.  

The path to qurun must, of course, match the path to qurun you established
above.
 
Then you need to tell querulator about your environment, which you
should do via a location directive to apache:

::

  <Location /ql>
      SetEnv GAVO_HOME /var/gavo  # or whatever
      SetEnv GAVOSETTINGS /var/gavo/web/gavosettings # or whatever
      SetEnv QU_ROOT /ql
      SetEnv QU_STATIC /qstatic
  </Location>

If you chose a QU_ROOT different from /ql, you need to change this, of
course.

The QU_STATIC setting must, of course, match what you set up above.

You may want to restrict access to your database.  Apart from the
ownership management of products, querulator leaves this to apache, so
you can use basically anything that apache supports.  The URIs the
querulator uses have the structure ``QU_ROOT/<op>/<template-path>``,
so to restrict access to certain templates, you could use something like

::

  <LocationMatch "/ql/.*/observatories">
    Deny from All
    Satisfy Any
    Require valid-user
    AuthType Basic                                
    AuthName "Protected VO Resources"                
    AuthUserFile /etc/apache2/htpasswd
  </LocationMatch>

That would require people to log on if they wanted to use any part of
the querulator requiring access to a template beyond observatories.

Note that ``AuthType Basic`` isn't much of a secure solution (at least
without running https).  Ask your local apache guru for more details.

After restarting apache, you should now be able to access
<your-server-url>/ql.  The script will complain about an I/O error --
that is because you have not defined the top-level query directory.


mod_python installation
+++++++++++++++++++++++

The configuration section should look like this:

::

  <Location /ql>
    SetHandler python-program
    PythonHandler gavo.web.querulator.querulator::handler
    SetEnv GAVO_HOME /var/gavo
    SetEnv GAVOSETTINGS /var/gavo/web/gavosettings
    SetEnv QU_ROOT /ql
    SetEnv QU_STATIC /qstatic
  </Location>

Access control would work like in the CGI case.

Defining queries
================

Queries are defined using Templates_ in the querulator.  These templates
are just files that can be organized in subdirectories.  Queries within
a subdirectory can link to one another using the querysel macro, so
they're supposed to be related, e.g., give various views on the same
dataset.

The querulator looks for the queries below the directory
``$GAVO_HOME/web/querulator/templates``.  Create that directory, and
you'll see the I/O error mentioned at the end of the last section
disappear: The querulator now says that there are not queries here and
no further queries.

"Queries here" would be templates in the current directory, "further
queries" lead to subdirectories of the current directory.  Make a
subdirectory, say, "sandbox", reload, and you'll see it appear under
"further queries".  Put a template in there, and you'll see it under
"queries available here".

Templates
=========

The Querulator works on templates.  These are basically HTML files you
can generate in any way you like (it's probably a good idea to use some
kind of static templating).  Within these HTML files, you can have an
embedded query that looks somewhat like

::

  <?query SELECT
  {{localid||string}},
  {{raRaw||string}},
  {{decRaw||string}},
  {{pm||real}},
  {{pmpa||real}},
  {{spectral||string}},
  {{mag||string}},
  {{alphaFloat \|\| ' ' \|\| deltaFloat|Open in aladin|aladinquery}},
  {{remarks||string}}
  FROM cns4.data WHERE 
  {{Proper motion from|pm BETWEEN BetweenCondGen()}} AND
  {{Position angle|pmpa BETWEEN BetweenCondGen()}} AND
  {{Spectral data like|spectral LIKE PatternField(10)}}
  ?>

Basically, you have an SQL statement (the grammar used to parse this
isn't a full SQL grammar, so you might have to complain to the author to
get support for some construct you need).  In order to support
auto-generation of query forms and responses from this, there is some
embedded markup: Select items and processed conditions.

Select items
************

Select items are in enclosed in double curly braces and consist of three
fields, seperated by a vertical bar (the vertical bar is a meta
character and needs to be escaped with a backslash if you need it in the
SQL expression or the title).  The
first is a (fairly arbitrary) sql expression that defines the data
to be formatted, the second is a column title (if the SQL expression
refers to a single column, you may leave that empty and the 
column title defined by the resource descriptor will be used if
available), the third is a formatting hint.

The formatting hint tells querulator how to present the given piece of
information.  Quite a bit of it is only relevant to HTML output.
Formatting hints are defined by gavo.web.querulator.queryrun.Formatter
-- refer to its documentation for the most recent information.
Meanwhile, here's a list of relevant formatting hints:

* date -- takes a date or timestamp and produces a date (without time)
  in ISO format
* juliandate -- takes a date or timestamp and produces a (full) julian
  date
* product -- takes a product key and produces a link to access it
* aladinload -- takes ra and dec in J2000.0 floats and produces a link
  to open it in aladin
* url -- takes some string and formats it as a link if outputting to
  HTML
* string -- takes some string and escapes it for the desired output.
  This should work fine for integers
* real -- formats real numbers

Processed conditions
********************

While you can use literal SQL conditions in your WHERE clauses, it's
usually much more interesting to do processed conditions.  These are
again enclosed in double curly braces and have to parts, seperated by
one vertical bar.

The first is a textual description of the condition.  These should be
unique within a document, since right now, these names serve to generate
form keys.

The second part is again an SQL expression with the special hack that as
a rule, the second operand constructs a condition generator.  Some
condition generators produce their own operators, so these don't even
have an operator and a first operand.  The purpose of these condition
generators is to come up with an HTML form element at form creation time
and to generate the appropriate SQL at query time.

The following is a list of available condition generators.

.. !!python ../gavo/web/querulator/condgens.py docs "+"

.. vi:tw=72:et:
