=========
How Do I?
=========

This is a list of recipies for slightly advanced things you might want
to do with the GAVO DC.


...skip a row from a rowmaker?
------------------------------

Raise IgnoreThisRow in a procedure application, like this::

  <rowmaker id="build_mytable" idmaps="*">
    <apply>
      <code>
        if 2+colX>22:
          raise IgnoreThisRow()
      </code>
    </apply>
  </rowmaker>


However, it's probably more desirable to use the rowmakers' built-in
``ignoreOn`` feature, possibly in connection with a procedure, since it is
more declarative.


...skip a single source?
------------------------

If you want to skip processing of a source, you can raise SkipThis from
an appropriate place.  Usually, this will be a sourceFields element,
like this::

  <reGrammar>
		<sourceFields>
			<code>
				if len(sourceToken)>22:
          raise base.SkipThis("%s skipped since I didn't like the name"%
            sourceToken)
       </code>
    </sourceFields>
  </sourceFields>


...set a constant input to a core?
----------------------------------

Use a service input key with a Hidden widget factory and a default::

  <service id="cutout" ...>
    ...
    <inputKey name="cutoutSize" widgetFactory="Hidden">
      <values default="0.1"/>
    </inputKey>
  </service>


...get a multi-line text input for an input key?
------------------------------------------------

Use a widgetFactory, like this::

		<inputKey original="adqlInput.query"
				widgetFactory="widgetFactory(ScalingTextArea, rows=15)"/>



...add computed columns to a dbCore output?
-------------------------------------------

Easy: define an output field with a select attribute, e.g.::

      <outputField name="a_U" tablehead="A_U" ucd="phys.absorption;em.opt.U"
        description="Extinction in U, assuming R_V=3.1"
        select="ev_i*5.434"/>

This will add an output field that looks to the service like it comes
from the DB proper but contains the value of the ``ev_i`` column
multiplied with 5.434.

The expression must be valid SQL.


...make an input widget to select output columns?
------------------------------------------------------

In general, selecting fancy output options currently requires custom
cores or custom renderers.  Ideas on how to change this are welcome.

For this specific purpose, however, you can simply define an service key
named _ADDITEM.  This would look like this::

  <service ....>
    ....
     <inputKey name="_ADDITEM" tablehead="Extinctions for band"
      description="Output extinctions for the respective band (if you want multiple bands, you can use 'additional output fields' below)"
      type="text" required="True" mul>
      <values multiOk="True" showItems="-1">
        <option title="Landolt U">a_U</option>
        <option title="Landolt V">a_V</option>
        <option title="Landolt I">a_I</option>
      </values>
    </inputKey>
    ...
  </service>

Setting showItems to -1 gives you checkboxes rather than a select list,
which is mostly what you want.  Try with and without and see what you
like better.

If you do that, you *probably* do not want the standard "additional
fields" widget at the bottom of the form.  To suppress it, add a line

::

  <property name="noAdditionals">True</property>
  
to the service definition.  The "True" in there actually is a bit of a
red herring, the widget is suppressed for any value.


...add and image to query forms?
--------------------------------

There are various variations to that theme -- you could go for a
custom template if you want to get fancy, but usually putting an image
into an _intro or _bottominfo meta section should do.

In both cases, you need a place to get your image from.  While you could
put it somewhere into rootDir/web/nv_static, it's probably nicer to have
it within a resource's input directory.  So, add a static renderer to
your service, like this::

  <service allowed="form,static">
    <property name="staticData">static</property>

This lets you put service-local static data into resdir/static/ and
access it as <serviceURL>/static/<filename>

Usually, your _intro or _bottominfo will be in reStructured text.  Plain
images work in there using substitution references or simply the naked
image directive::

    <meta name="_bottominfo" format="rst">
      The current data set comprises these fields:

      .. image:: \servicelink{cars/q/cat/static/fields-inline.png}
    </meta>

The servicelink macro would ensure that the image would still be found
if the server ran off-root.

This is the recommended way of doing things.  If, however, you insist on
fancy layouts or need complete control over the appearance of your
image (or whatever), you can use the evil "raw" meta format::
  
  <meta name="_bottominfo" format="raw"><![CDATA[
    <a href="\servicelink{cars/q/cat/static/fields.png}">
    <img src="\servicelink{cars/q/cat/static/fields-inline.png}"/>
    </a>]]>
  </meta>

Make sure you enter valid HTML here, no checks are done by the DC
software.


...import data coming in to a service?
--------------------------------------

In a custom renderer or core, you can use code like::

  from gavo import api

  ...

  def import(self, srcName, srcFile):
    connection = api.getDBConnection("admin")
    dd = self.service.rd.getById("myDataId")
    self.nAffected = api.makeData(dd, forceSource=srcFile,
      connection=connection).nAffected
    connection.commit()
    connection.close()

You want to use a separate connection since the default connections
obtained by cores and friends are unprivileged and typically cannot
write to table.

The nAffected should contain the total number of records imported and
could be used in a custom render function.

srcName and srcFile come from a formal File form item.  In
submitActions, you obtain them like::

  srcName, srcFile = data["inFile"]


Note that you can get really fancy and manipulate data in some way up
front.  That could look like this::

  data = rsc.Data.create(dd, parseOptions=api.parseValidating,
    connection=connection)
  data.addMeta("_stationId", self.stationRecord["stationId"])
  self.nAffected = api.makeData(dd, forceSource=srcFile, data=data,
    connection=connection).nAffected


...change the query issued on SCS queries?
------------------------------------------

You may want to do that because for some reason there is no q3c index on
the queried table, or the semantics aren't quite a point vs. point cone
search but close enough.

Sadly, this is quite complicated right now since our inheritance
mechanism ("original") is so simple-minded.  This will hopefully improve
with a generic record/replay mechanism we're thinking about.

That said, the current way looks like this (for a query that does a
proximity search on bboxes)::

  <condDesc original="//scs#humanInput">
    <phraseMaker original="//scs#humanSCSPhrase">
      <setup original="//scs#scsSetup" id="proxQuery">
        <code><![CDATA[
          def genQuery(inPars, outPars):
            return "POINT(%%(%s)s, %%(%s)s) <-> bbox < %%(%s)s"%(
              vizierexprs.getSQLKey("RA", inPars["RA"], outPars),
              vizierexprs.getSQLKey("DEC", inPars["DEC"], outPars),
              vizierexprs.getSQLKey("SR", inPars["SR"], outPars))
        ]]></code>
      </setup>
    </phraseMaker>
  </condDesc>

-- so, you are inheriting from the SCS condition on three levels and then 
override the genQuery function defined in the common setup code.  The
way the condDescs are written, you must return rather than yield
the actual query string.  See the tutorial on how condDesc code
works in general.  The semi-good news is that if you want the same thing
for an SCS query, you can reuse part of what you did above::

   <condDesc original="//scs#procInput">
    <phraseMaker original="//scs#scsPhrase">
      <setup original="proxQuery"/>
    </phraseMaker>
  </condDesc>


...create database views in data elements?
------------------------------------------

There's a catch going beyond using simpleView or tables with
viewStatements: views evidently depend on the existence of tables.
It would seem this does not hurt when you have a data definition like::

  <data id="build">
    <make table="a"/>
    <make table="v"/>
  </data>

where ``v`` is the view depending on the table ``a``.  The trouble with
this is that as soon as you change ``a``, the data build cannot be
re-created; you cannot even drop it if you deleted the view v (in that
case, just manually drop table a, and things work again.

The reason for this odd behaviour is somewhat subtle, and I'll explain
it here when someone asks.  The upshot, however, is: Never ``make`` a
view in the same ``data`` as a table it depends on.  This right way to
do what's intended above is::

  <data id="build" dependents="makeView">
    <make table="a"/>
  </data>

  <data id="makeView" auto="False">
    <make table="b"/>
  </data>


...fix duplicate values?
------------------------

There are many reasons why you could violate the uniqueness constraints on
primary keys, but let's say you just got a message saying::

  Primary key <whatever> could not be added ('could not create unique 
  index "data_pkey" DETAIL:  Table contains duplicated values.)'

The question at this point is: What are the duplicated values?  For a
variety of reasons, DaCHS only applies constraints only after inserting
all the data, so the error will occur at the end of the input.  Not even
the ``-b1`` trick will help you here.

Instead, temporarily remove the primary key condition from the RD and
import your data.

Then, exececute a query like::

  select * 
  from (
    select <primary-col>, count(*) as ct 
    from <your-table>
    group by <primary-col>) as q 
  where ct>1;
