========================
The GAVO VOTable Library
========================

A library to process VOTables  using python
========================================================================

:Author: Markus Demleitner
:Email: gavo@ari.uni-heidelberg.de


.. contents:: 
  :depth: 2
  :backlinks: entry
  :class: toc


Iterative Parsing
-----------------

Iterative parsing is well suited for streaming applications and is
attractive because the full document need never be completely in RAM at
the same time.  For many applications, it is a little more clunky to
work with, though.

The central function for iterative parsing is parse::

  parse(inFile, watchset=[]) -> iterator

There also is ``parseString`` that takes a string literal instead of a file.
``inFile`` may be anything acceptable to the Elementtree library, so
files and file names are ok.

The watchlist gives additional element types you want the iterator to
return.  These have to be classes from ``votable.V``.  By default, only
special votable.Rows objects are returned.  More on those below.

You get back ``xmlstan.Element`` instances with some additional
attributes:

* ``idmap`` is a dictionary-like object mapping ids to the elements that
  have so far been seen.  This is the same object for all items
  returned, so forward references will at least been resolved in this
  ``idmap`` if the input document is valid.  For documents with clashing
  ids, the behaviour is undefined.



Special behaviour
-----------------

From the standards document it is not clear if, on parsing, nullvalue
comparison should happen on literals or on parsed values.  In this
library, we went for literal comparison.  This means that, e.g., for
unsignedBytes with a null value of 0x10, a decimal 16 will not be
rendered as None.

Values of VOTable type bits are always returned as integers, possibly 
very long ones.

Arraysize specifications are ignored when parsing VOTables in TABLEDATA
encoding.  The resulting lists will have the length given by the input.
When writing, arraysizes are mostly enforced by clipping or padding with
null values.  They currently are not for strings and bit arrays.

One consequence of this is that with ``arraysize="*"``, a NULL array
will be an empty tag in TABLEDATA, but with ``arraysize='n'`` it
will be n nullvalues.

Bit arrays in TABLEDATA encoding may have interspersed whitespace or
not.  When encoding, no whitespace is generated since this seems the
intention of the spec.

All VOTables generated by this library are in UTF-8.

unicodeChar in BINARY encodes to and from UTF-16 rather than UCS-2 since
UCS-2 is deprecated (and actually unsupported by python's codecs).
However, this will fail for fixed-size strings containing characters
outside of the BMP since it is impossible to know how many bytes an
unknown string will occupy in UTF-16.  So, characters for which UCS-2
and UTF-16 are different will fail.  These probably are rare, but we
should figure out some way to handle this.

This will only make a difference for characters outside of the Basic
Multilingual Plane.  Hope you'll never encounter any.

Nullvalue declarations for booleans are always ignored.  Nullvalue
declarations for floats, doubles, and their complex counterparts
are ignored when writing (i.e., we will always use NaN as a
nullvalue; anything else would be highly doubtful anyway since
float coming from representations in binary and decimal are tricky
to compare at best).

When serializing bit fields in BINARY and there are too many bits for
the number of *bytes* available, the most significant bits are cut off.
If there are too few, zeroes are added on the left.

Post-data INFOs are not currently accessible when doing iterative
parsing.

In BINARY serialization, fixed-length strings (both char and
unicodeChar) are always padded right with blanks, whether or not a
nullvalue is defined.

For char and unicodeChar arrays, nullvalues are supposed to refer to
the entire array value.  This is done since probably no library will
support individual NULL characters (whatever that is) within strings,
and this *if* we encounter such a thing, this probably is the meaning.
Don't write something like that, though.

When deserializing variable multidimensional arrays from BINARY encoded
streams, the length is assumed to be the total number of elements in
the array rather than the number of rows.  This may change when
I find some VOTable using this in the wild.

Multidimensional arrays are returned as a single sequence on parsing,
i.e. an arraysize of 5x7 is interpreted exactly like 35.  This is not
going to change.  If you must, you can use the
``unravel|Array(arraysize, seq)`` function to reshape the list and get a
nested structure of lists, where arraysize has the form of the
VOTable FIELD attribute. If seq does not match the dimensions described
by arraysize, the behavior is undefined (right now, we return short
rows, but we may later raise exceptions).

On writing, you must flatten your multidimensional arrays before passing
them to the library.  This may change if people actually use it.  The
behavior then will be to accept as input whatever unravelArray returns.
You can guess that the author considers multidimensional arrays a
particularly gross misfeature within the misfeature VOTable arrays.
