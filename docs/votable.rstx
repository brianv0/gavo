========================
The GAVO VOTable Library
========================

A library to process VOTables  using python
========================================================================

:Author: Markus Demleitner
:Email: gavo@ari.uni-heidelberg.de


.. contents:: 
  :depth: 2
  :backlinks: entry
  :class: toc


Iterative Parsing
-----------------

Iterative parsing is well suited for streaming applications and is
attractive because the full document need never be completely in RAM at
the same time.  For many applications, it is a little more clunky to
work with, though.

The central function for iterative parsing is parse::

  parse(inFile, watchset=[]) -> iterator

There also is ``parseString`` that takes a string literal instead of a file.
``inFile`` may be anything acceptable to the Elementtree library, so
files and file names are ok.

The watchlist gives additional element types you want the iterator to
return.  These have to be classes from ``votable.V``.  By default, only
special votable.Rows objects are returned.  More on those below.

You get back ``xmlstan.Element`` instances with some additional
attributes:

* ``idmap`` is a dictionary-like object mapping ids to the elements that
  have so far been seen.  This is the same object for all items
  returned, so forward references will at least been resolved in this
  ``idmap`` if the input document is valid.  For documents with clashing
  ids, the behaviour is undefined.



Special behaviour
-----------------

From the standards document it is not clear if, on parsing, nullvalue
comparison should happen on literals or on parsed values.  In this
library, we went for literal comparison.  This means that, e.g., for
unsignedBytes with a null value of 0x10, a decimal 16 will not be
rendered as None.

Values of VOTable type bits are always returned as integers, possibly 
very long ones.

Arraysize specifications are ignored when parsing VOTables in TABLEDATA
encoding.  The resulting lists will have the length given by the input.
When writing, arraysizes are mostly enforced by clipping or padding with
null values (see below on null values for floats an friends, though).
They currently are not for strings and bit arrays.

One consequence of this is that with ``arraysize="*"``, a NULL array
will be an empty tag in TABLEDATA, but with ``arraysize='n'`` it
will be n nullvalues.

Bit arrays in TABLEDATA encoding may have interspersed whitespace or
not.  When encoding, no whitespace is generated since this seems the
intention of the spec.

When you encode arrays of types having default nullvalues in TABLEDATA
coding (most notably, float and double) and there are Nones in your
arrays, these entries will be skipped unless you specify a real null
value.

All VOTables generated by this library are in UTF-8.

unicodeChar in BINARY uses UTF-16 rather than UCS-2.  This will only
make a difference for characters outside of the Basic Multilingual
Plane.  Hope you'll never encounter any.

Nullvalue declarations for booleans are always ignored.  Nullvalue
declarations for floats, doubles, and their complex counterparts
are ignored for BINARY encoding (i.e., you can only use NaN as a
nullvalue).

When serializing bit fields in BINARY and there are too many bits for
the number of *bytes* available, the most significant bits are cut off.
If there are too few, zeroes are added on the left.

Post-data INFOs are not currently accessible when doing iterative
parsing.
